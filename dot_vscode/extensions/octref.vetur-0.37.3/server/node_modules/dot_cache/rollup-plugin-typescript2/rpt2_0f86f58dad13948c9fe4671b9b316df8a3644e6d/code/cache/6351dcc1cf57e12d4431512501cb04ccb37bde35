{"code":"/**\r\n * Walk all descendant expressions included root node naively. Not comprehensive walker.\r\n * Traversal type is post-order (LRN).\r\n * If some expression node is returned in predicate function, the node will be replaced.\r\n */\r\nexport function walkExpression(tsModule, root, predicate) {\r\n    function visit(node, scope) {\r\n        return predicate(node, scope) || node;\r\n    }\r\n    function update(changes, original, updated) {\r\n        const changedKeys = Object.keys(changes);\r\n        const isUpdated = changedKeys.reduce((acc, key) => {\r\n            return acc || changes[key] !== original[key];\r\n        }, false);\r\n        return isUpdated ? tsModule.setTextRange(updated, original) : original;\r\n    }\r\n    function loop(node, scope) {\r\n        if (tsModule.isPropertyAccessChain(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            return visit(update({ expression }, node, tsModule.createPropertyAccessChain(expression, node.questionDotToken, node.name)), scope);\r\n        }\r\n        if (tsModule.isPropertyAccessExpression(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            return visit(update({ expression }, node, tsModule.createPropertyAccess(expression, node.name)), scope);\r\n        }\r\n        if (tsModule.isElementAccessExpression(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            const argumentExpression = loop(node.argumentExpression, scope);\r\n            return visit(update({ expression, argumentExpression }, node, tsModule.createElementAccess(expression, argumentExpression)), scope);\r\n        }\r\n        if (tsModule.isPrefixUnaryExpression(node)) {\r\n            const operand = loop(node.operand, scope);\r\n            return visit(update({ operand }, node, tsModule.createPrefix(node.operator, operand)), scope);\r\n        }\r\n        if (tsModule.isPostfixUnaryExpression(node)) {\r\n            const operand = loop(node.operand, scope);\r\n            return visit(update({ operand }, node, tsModule.createPostfix(operand, node.operator)), scope);\r\n        }\r\n        // Manually check `kind` for typeof expression\r\n        // since ts.isTypeOfExpression is not working.\r\n        if (node.kind === tsModule.SyntaxKind.TypeOfExpression) {\r\n            const n = node;\r\n            const expression = loop(n.expression, scope);\r\n            return visit(update({ expression }, n, tsModule.createTypeOf(expression)), scope);\r\n        }\r\n        if (tsModule.isDeleteExpression(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            return visit(update({ expression }, node, tsModule.createDelete(expression)), scope);\r\n        }\r\n        if (tsModule.isVoidExpression(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            return visit(update({ expression }, node, tsModule.createVoid(expression)), scope);\r\n        }\r\n        if (tsModule.isBinaryExpression(node)) {\r\n            const left = loop(node.left, scope);\r\n            const right = loop(node.right, scope);\r\n            return visit(update({ left, right }, node, tsModule.createBinary(left, node.operatorToken, right)), scope);\r\n        }\r\n        if (tsModule.isConditionalExpression(node)) {\r\n            const condition = loop(node.condition, scope);\r\n            const whenTrue = loop(node.whenTrue, scope);\r\n            const whenFalse = loop(node.whenFalse, scope);\r\n            return visit(update({ condition, whenTrue, whenFalse }, node, tsModule.createConditional(condition, whenTrue, whenFalse)), scope);\r\n        }\r\n        if (tsModule.isCallExpression(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            const args = mapNodeArray(tsModule, node.arguments, arg => loop(arg, scope));\r\n            return visit(update({ expression, arguments: args }, node, tsModule.createCall(expression, node.typeArguments, args)), scope);\r\n        }\r\n        if (tsModule.isParenthesizedExpression(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            return visit(update({ expression }, node, tsModule.createParen(expression)), scope);\r\n        }\r\n        if (tsModule.isObjectLiteralExpression(node)) {\r\n            const properties = mapNodeArray(tsModule, node.properties, p => {\r\n                return walkObjectLiteralElementLike(p, scope);\r\n            });\r\n            return visit(update({ properties }, node, tsModule.createObjectLiteral(properties)), scope);\r\n        }\r\n        if (tsModule.isArrayLiteralExpression(node)) {\r\n            const elements = mapNodeArray(tsModule, node.elements, el => loop(el, scope));\r\n            return visit(update({ elements }, node, tsModule.createArrayLiteral(elements)), scope);\r\n        }\r\n        if (tsModule.isSpreadElement(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            return visit(update({ expression }, node, tsModule.createSpread(expression)), scope);\r\n        }\r\n        if (tsModule.isArrowFunction(node)) {\r\n            const fnScope = scope.concat(flatMap(node.parameters, value => collectScope(tsModule, value)));\r\n            let body;\r\n            if (tsModule.isBlock(node.body)) {\r\n                const statements = mapNodeArray(tsModule, node.body.statements, st => {\r\n                    if (tsModule.isExpressionStatement(st)) {\r\n                        const expression = loop(st.expression, fnScope);\r\n                        return update({ expression }, st, tsModule.createExpressionStatement(expression));\r\n                    }\r\n                    else {\r\n                        return st;\r\n                    }\r\n                });\r\n                body = update({ statements }, node.body, tsModule.createBlock(statements));\r\n            }\r\n            else {\r\n                body = loop(node.body, fnScope);\r\n            }\r\n            return visit(update({ body }, node, tsModule.createArrowFunction(node.modifiers, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, body)), scope);\r\n        }\r\n        if (tsModule.isTemplateExpression(node)) {\r\n            const templateSpans = mapNodeArray(tsModule, node.templateSpans, span => {\r\n                const expression = loop(span.expression, scope);\r\n                return update({ expression }, span, tsModule.createTemplateSpan(expression, span.literal));\r\n            });\r\n            return visit(update({ templateSpans }, node, tsModule.createTemplateExpression(node.head, templateSpans)), scope);\r\n        }\r\n        if (tsModule.isNewExpression(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            const args = node.arguments && mapNodeArray(tsModule, node.arguments, arg => loop(arg, scope));\r\n            return update({\r\n                expression,\r\n                arguments: args\r\n            }, node, tsModule.createNew(expression, node.typeArguments, args));\r\n        }\r\n        return visit(node, scope);\r\n    }\r\n    function walkObjectLiteralElementLike(node, scope) {\r\n        if (tsModule.isPropertyAssignment(node)) {\r\n            let name;\r\n            if (tsModule.isComputedPropertyName(node.name)) {\r\n                const expression = loop(node.name.expression, scope);\r\n                name = update({ expression }, node.name, tsModule.createComputedPropertyName(expression));\r\n            }\r\n            else {\r\n                name = node.name;\r\n            }\r\n            const initializer = loop(node.initializer, scope);\r\n            return update({ name, initializer }, node, tsModule.createPropertyAssignment(name, initializer));\r\n        }\r\n        if (tsModule.isSpreadAssignment(node)) {\r\n            const expression = loop(node.expression, scope);\r\n            return update({ expression }, node, tsModule.createSpreadAssignment(expression));\r\n        }\r\n        return node;\r\n    }\r\n    return loop(root, []);\r\n}\r\n/**\r\n * Collect newly added variable names from function parameters.\r\n * e.g.\r\n * If the function parameters look like following:\r\n *   (foo, { bar, baz: qux }) => { ... }\r\n * The output should be:\r\n *   ['foo', 'bar', 'qux']\r\n */\r\nfunction collectScope(tsModule, param) {\r\n    const binding = param.name;\r\n    if (tsModule.isIdentifier(binding)) {\r\n        return [binding];\r\n    }\r\n    else if (tsModule.isObjectBindingPattern(binding)) {\r\n        return flatMap(binding.elements, value => collectScope(tsModule, value));\r\n    }\r\n    else if (tsModule.isArrayBindingPattern(binding)) {\r\n        const filtered = binding.elements.filter(tsModule.isBindingElement);\r\n        return flatMap(filtered, value => collectScope(tsModule, value));\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Map node array to the same item type. If all item references are not changed, it returns the input list.\r\n */\r\nfunction mapNodeArray(tsModule, list, fn) {\r\n    const mapped = list.map(fn);\r\n    const isUpdated = mapped.some((v, i) => {\r\n        const old = list[i];\r\n        return v !== old;\r\n    });\r\n    return isUpdated ? tsModule.createNodeArray(mapped) : list;\r\n}\r\nfunction flatMap(list, fn) {\r\n    return list.reduce((acc, item) => {\r\n        return acc.concat(fn(item));\r\n    }, []);\r\n}\r\n//# sourceMappingURL=walkExpression.js.map","references":["/Users/yoyo930021/git/vetur/server/node_modules/typescript/lib/typescript.d.ts","/Users/yoyo930021/git/vetur/server/src/services/dependencyService.ts"],"map":"{\"version\":3,\"file\":\"walkExpression.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/services/typescriptService/walkExpression.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/yoyo930021/git/vetur/server/node_modules/.cache/rollup-plugin-typescript2/placeholder/services/typescriptService/walkExpression.d.ts","writeByteOrderMark":false,"text":"import type ts from 'typescript';\r\nimport { RuntimeLibrary } from '../dependencyService';\r\n/**\r\n * Walk all descendant expressions included root node naively. Not comprehensive walker.\r\n * Traversal type is post-order (LRN).\r\n * If some expression node is returned in predicate function, the node will be replaced.\r\n */\r\nexport declare function walkExpression(tsModule: RuntimeLibrary['typescript'], root: ts.Expression, predicate: (node: ts.Expression, additionalScope: ts.Identifier[]) => ts.Expression | void): ts.Expression;\r\n"}}
