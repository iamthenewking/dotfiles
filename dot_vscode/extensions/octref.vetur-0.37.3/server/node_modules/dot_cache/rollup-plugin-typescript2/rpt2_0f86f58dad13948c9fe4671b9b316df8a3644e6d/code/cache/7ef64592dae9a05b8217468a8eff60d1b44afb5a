{"code":"import { kebabCase, snakeCase } from 'lodash';\r\nimport { walkExpression } from './walkExpression';\r\nexport const renderHelperName = '__vlsRenderHelper';\r\nexport const componentHelperName = '__vlsComponentHelper';\r\nexport const iterationHelperName = '__vlsIterationHelper';\r\nexport const componentDataName = '__vlsComponentData';\r\n/**\r\n * Allowed global variables in templates.\r\n * Borrowed from: https://github.com/vuejs/vue/blob/dev/src/core/instance/proxy.js\r\n */\r\nexport const globalScope = ('Infinity,undefined,NaN,isFinite,isNaN,' +\r\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\r\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\r\n    'require').split(',');\r\nconst vOnScope = ['$event', 'arguments'];\r\n/**\r\n * @param tsModule Loaded TS dependency\r\n * @param childComponentNamesInSnakeCase If `VElement`'s name matches one of the child components'\r\n * name, generate expression with `${componentHelperName}__${name}`, which will enforce type-check\r\n * on props\r\n */\r\nexport function getTemplateTransformFunctions(tsModule, childComponentNamesInSnakeCase) {\r\n    return {\r\n        transformTemplate,\r\n        parseExpression\r\n    };\r\n    /**\r\n     * Transform template AST to TypeScript AST.\r\n     * Note: The returned TS AST is not compatible with\r\n     * the regular Vue render function and does not work on runtime\r\n     * because we just need type information for the template.\r\n     * Each TypeScript node should be set a range because\r\n     * the compiler may clash or do incorrect type inference\r\n     * when it has an invalid range.\r\n     */\r\n    function transformTemplate(program, code) {\r\n        const template = program.templateBody;\r\n        if (!template) {\r\n            return [];\r\n        }\r\n        return transformChildren(template.children, code, globalScope);\r\n    }\r\n    /**\r\n     * Transform an HTML to TypeScript AST.\r\n     * It will be a call expression like Vue's $createElement.\r\n     * e.g.\r\n     * __vlsComponentHelper('div', { props: { title: this.foo } }, [ ...children... ]);\r\n     */\r\n    function transformElement(node, code, scope) {\r\n        /**\r\n         * `vModel`      -> need info from other components to do type check\r\n         * `v-bind`      -> do this later\r\n         * `v-bind:[foo] -> don't do type-check. do make `[]` an interpolation area\r\n         */\r\n        const hasUnhandledAttributes = node.startTag.attributes.some(attr => {\r\n            return isVModel(attr) || (isVBind(attr) && !isVBindShorthand(attr)) || isVBindWithDynamicAttributeName(attr);\r\n        });\r\n        const identifier = !hasUnhandledAttributes &&\r\n            childComponentNamesInSnakeCase &&\r\n            childComponentNamesInSnakeCase.indexOf(snakeCase(node.rawName)) !== -1\r\n            ? tsModule.createIdentifier(componentHelperName + '__' + snakeCase(node.rawName))\r\n            : tsModule.createIdentifier(componentHelperName);\r\n        return tsModule.createCall(identifier, undefined, [\r\n            // Pass this value to propagate ThisType in listener handlers\r\n            tsModule.createIdentifier('this'),\r\n            // Element / Component name\r\n            tsModule.createLiteral(node.name),\r\n            // Attributes / Directives\r\n            transformAttributes(node, node.startTag.attributes, code, scope),\r\n            // Children\r\n            tsModule.createArrayLiteral(transformChildren(node.children, code, scope))\r\n        ]);\r\n    }\r\n    function transformAttributes(node, attrs, code, scope) {\r\n        const data = {\r\n            props: [],\r\n            on: [],\r\n            directives: []\r\n        };\r\n        attrs.forEach(attr => {\r\n            // Normal attributes\r\n            // e.g. title=\"title\"\r\n            if (isVAttribute(attr)) {\r\n                const name = attr.key.name;\r\n                // Skip style and class because there may be v-bind for the same attribute which\r\n                // occurs duplicate property name error.\r\n                // Since native attribute value is not JS expression, we don't have to check it.\r\n                if (name !== 'class' && name !== 'style') {\r\n                    data.props.push(transformNativeAttribute(attr));\r\n                }\r\n                return;\r\n            }\r\n            // v-bind directives\r\n            // e.g. :class=\"{ selected: foo }\"\r\n            if (isVBind(attr)) {\r\n                data.props.push(transformVBind(attr, code, scope));\r\n                return;\r\n            }\r\n            // v-on directives\r\n            // e.g. @click=\"onClick\"\r\n            if (isVOn(attr)) {\r\n                data.on.push(transformVOn(attr, code, scope));\r\n                return;\r\n            }\r\n            // Skip v-slot, v-for and v-if family directive (handled in `transformChildren`)\r\n            if (isVSlot(attr) || isVFor(attr) || isVIf(attr) || isVElseIf(attr) || isVElse(attr)) {\r\n                return;\r\n            }\r\n            // Other directives\r\n            const exp = transformDirective(attr, code, scope);\r\n            if (exp) {\r\n                data.directives.push(...exp);\r\n            }\r\n        });\r\n        // Fold all AST into VNodeData-like object\r\n        // example output:\r\n        // {\r\n        //   props: { class: 'title' },\r\n        //   on: { click: __vlsListenerHelper(this, function($event) { this.onClick($event) } }\r\n        // }\r\n        const propsAssignment = tsModule.createPropertyAssignment('props', tsModule.createObjectLiteral(data.props));\r\n        tsModule.setSourceMapRange(propsAssignment.name, {\r\n            pos: node.startTag.range[0] + '<'.length,\r\n            end: node.startTag.range[0] + '<'.length + node.rawName.length\r\n        });\r\n        return tsModule.createObjectLiteral([\r\n            propsAssignment,\r\n            tsModule.createPropertyAssignment('on', tsModule.createObjectLiteral(data.on)),\r\n            tsModule.createPropertyAssignment('directives', tsModule.createArrayLiteral(data.directives))\r\n        ]);\r\n    }\r\n    function transformNativeAttribute(attr) {\r\n        return tsModule.createPropertyAssignment(tsModule.createStringLiteral(attr.key.name), attr.value ? tsModule.createLiteral(attr.value.value) : tsModule.createLiteral(true));\r\n    }\r\n    function transformVBind(vBind, code, scope) {\r\n        const exp = vBind.value ? transformExpressionContainer(vBind.value, code, scope) : tsModule.createLiteral(true);\r\n        return directiveToObjectElement(vBind, exp, code, scope);\r\n    }\r\n    function transformVOn(vOn, code, scope) {\r\n        let exp;\r\n        if (vOn.value) {\r\n            if (!vOn.key.argument) {\r\n                // e.g.\r\n                //   v-on=\"$listeners\"\r\n                // Annotate the expression with `any` because we do not expect type error\r\n                // with bridge type and it. Currently, bridge type should only be used\r\n                // for inferring `$event` type.\r\n                exp = tsModule.createAsExpression(transformExpressionContainer(vOn.value, code, scope), tsModule.createKeywordTypeNode(tsModule.SyntaxKind.AnyKeyword));\r\n            }\r\n            else {\r\n                // e.g.\r\n                //   @click=\"onClick\"\r\n                //   @click=\"onClick($event, 'test')\"\r\n                // value.expression can be ESLintExpression (e.g. ArrowFunctionExpression)\r\n                const vOnExp = vOn.value.expression;\r\n                const newScope = scope.concat(vOnScope);\r\n                const statements = !vOnExp || vOnExp.type !== 'VOnExpression'\r\n                    ? [tsModule.createReturn(transformExpressionContainer(vOn.value, code, newScope))]\r\n                    : vOnExp.body.map(st => transformStatement(st, code, newScope));\r\n                const createParameter = (name) => {\r\n                    const [major, minor] = tsModule.version.split('.');\r\n                    if ((Number(major) === 4 && Number(minor) >= 8) || Number(major) > 4) {\r\n                        return tsModule.createParameter(undefined, undefined, name);\r\n                    }\r\n                    return tsModule.createParameter(undefined, undefined, undefined, name);\r\n                };\r\n                exp = tsModule.createFunctionExpression(undefined, undefined, undefined, undefined, [createParameter('$event')], undefined, tsModule.createBlock(statements));\r\n            }\r\n        }\r\n        else {\r\n            // There are no statement in v-on value\r\n            exp = tsModule.createFunctionExpression(undefined, undefined, undefined, undefined, undefined, undefined, tsModule.createBlock([]));\r\n        }\r\n        return directiveToObjectElement(vOn, exp, code, scope);\r\n    }\r\n    /**\r\n     * To transform v-bind and v-on directive\r\n     */\r\n    function directiveToObjectElement(dir, dirExp, code, scope) {\r\n        const name = dir.key.argument;\r\n        if (name) {\r\n            if (name.type === 'VIdentifier') {\r\n                // Attribute name is specified\r\n                // e.g. v-bind:value=\"foo\"\r\n                const fullName = dir.key.modifiers.length === 0 || isVBind(dir)\r\n                    ? kebabCase(name.rawName)\r\n                    : [kebabCase(name.rawName), ...dir.key.modifiers.map(m => m.rawName)].join('.');\r\n                const propNameNode = tsModule.setSourceMapRange(tsModule.createStringLiteral(fullName), {\r\n                    pos: name.range[0],\r\n                    end: name.range[1]\r\n                });\r\n                return tsModule.createPropertyAssignment(propNameNode, dirExp);\r\n            }\r\n            else {\r\n                // Attribute name is dynamic\r\n                // e.g. v-bind:[value]=\"foo\"\r\n                const propertyName = tsModule.createComputedPropertyName(transformExpressionContainer(name, code, scope));\r\n                return tsModule.createPropertyAssignment(propertyName, dirExp);\r\n            }\r\n        }\r\n        else {\r\n            // Attribute name is omitted\r\n            // e.g. v-bind=\"{ value: foo }\"\r\n            return tsModule.createSpreadAssignment(dirExp);\r\n        }\r\n    }\r\n    /**\r\n     * Return directive expression. May include dynamic argument expression.\r\n     */\r\n    function transformDirective(dir, code, scope) {\r\n        const res = [];\r\n        if (dir.key.argument && dir.key.argument.type === 'VExpressionContainer') {\r\n            res.push(transformExpressionContainer(dir.key.argument, code, scope));\r\n        }\r\n        if (dir.value) {\r\n            res.push(transformExpressionContainer(dir.value, code, scope));\r\n        }\r\n        return res;\r\n    }\r\n    function transformChildren(children, code, originalScope) {\r\n        // Pre-transform child nodes to make further transformation easier\r\n        function preTransform(children) {\r\n            const queue = children.slice();\r\n            function element(el, attrs) {\r\n                const vSlot = attrs.find(isVSlot);\r\n                if (vSlot && isVDirective(vSlot)) {\r\n                    const index = attrs.indexOf(vSlot);\r\n                    const scope = el.variables.filter(v => v.kind === 'scope').map(v => v.id.name);\r\n                    return {\r\n                        type: 'v-slot',\r\n                        vSlot,\r\n                        data: element(el, [...attrs.slice(0, index), ...attrs.slice(index + 1)]),\r\n                        scope\r\n                    };\r\n                }\r\n                // v-for has higher priority than v-if\r\n                // https://vuejs.org/v2/guide/list.html#v-for-with-v-if\r\n                const vFor = attrs.find(isVFor);\r\n                if (vFor && isVDirective(vFor)) {\r\n                    const index = attrs.indexOf(vFor);\r\n                    const scope = el.variables.filter(v => v.kind === 'v-for').map(v => v.id.name);\r\n                    return {\r\n                        type: 'v-for',\r\n                        vFor,\r\n                        data: element(el, [...attrs.slice(0, index), ...attrs.slice(index + 1)]),\r\n                        scope\r\n                    };\r\n                }\r\n                const vIf = attrs.find(isVIf);\r\n                if (vIf && isVDirective(vIf)) {\r\n                    const index = attrs.indexOf(vIf);\r\n                    return {\r\n                        type: 'v-if-family',\r\n                        directive: vIf,\r\n                        data: element(el, [...attrs.slice(0, index), ...attrs.slice(index + 1)]),\r\n                        next: followVIf()\r\n                    };\r\n                }\r\n                return {\r\n                    type: 'node',\r\n                    data: el\r\n                };\r\n            }\r\n            function followVIf() {\r\n                const el = queue[0];\r\n                if (!el || el.type !== 'VElement') {\r\n                    return undefined;\r\n                }\r\n                const attrs = el.startTag.attributes;\r\n                const directive = attrs.find(isVElseIf) || attrs.find(isVElse);\r\n                if (!directive || !isVDirective(directive)) {\r\n                    return undefined;\r\n                }\r\n                queue.shift();\r\n                return {\r\n                    type: 'v-if-family',\r\n                    directive,\r\n                    data: element(el, attrs),\r\n                    next: followVIf()\r\n                };\r\n            }\r\n            function loop(acc) {\r\n                const target = queue.shift();\r\n                if (!target) {\r\n                    return acc;\r\n                }\r\n                if (target.type !== 'VElement') {\r\n                    return loop(acc.concat({\r\n                        type: 'node',\r\n                        data: target\r\n                    }));\r\n                }\r\n                return loop(acc.concat(element(target, target.startTag.attributes)));\r\n            }\r\n            return loop([]);\r\n        }\r\n        function mainTransform(children) {\r\n            function genericTransform(child, scope) {\r\n                switch (child.type) {\r\n                    case 'v-for':\r\n                        return vForTransform(child, scope);\r\n                    case 'v-if-family':\r\n                        return vIfFamilyTransform(child, scope);\r\n                    case 'v-slot':\r\n                        return vSlotTransform(child, scope);\r\n                    case 'node':\r\n                        return nodeTransform(child, scope);\r\n                }\r\n            }\r\n            function vIfFamilyTransform(vIfFamily, scope) {\r\n                const dir = vIfFamily.directive;\r\n                const condition = dir.value\r\n                    ? transformExpressionContainer(dir.value, code, scope)\r\n                    : tsModule.createLiteral(true);\r\n                const next = vIfFamily.next ? vIfFamilyTransform(vIfFamily.next, scope) : tsModule.createLiteral(true);\r\n                return tsModule.createConditional(\r\n                // v-if or v-else-if condition\r\n                condition, \r\n                // element that the v-if family directive belongs to\r\n                genericTransform(vIfFamily.data, scope), \r\n                // next sibling element of v-if or v-else if any\r\n                next);\r\n            }\r\n            function vForTransform(vForData, scope) {\r\n                const vFor = vForData.vFor;\r\n                if (!vFor.value || !vFor.value.expression) {\r\n                    return genericTransform(vForData.data, scope);\r\n                }\r\n                // Convert v-for directive to the iteration helper\r\n                const exp = vFor.value.expression;\r\n                const newScope = scope.concat(vForData.scope);\r\n                return tsModule.createCall(tsModule.createIdentifier(iterationHelperName), undefined, [\r\n                    // Iteration target\r\n                    transformExpression(exp.right, code, scope),\r\n                    // Callback\r\n                    tsModule.createArrowFunction(undefined, undefined, parseParams(exp.left, code, scope), undefined, tsModule.createToken(tsModule.SyntaxKind.EqualsGreaterThanToken), genericTransform(vForData.data, newScope))\r\n                ]);\r\n            }\r\n            function vSlotTransform(vSlotData, scope) {\r\n                const vSlot = vSlotData.vSlot;\r\n                if (!vSlot.value || !vSlot.value.expression) {\r\n                    return genericTransform(vSlotData.data, scope);\r\n                }\r\n                const exp = vSlot.value.expression;\r\n                const newScope = scope.concat(vSlotData.scope);\r\n                return tsModule.createArrowFunction(undefined, undefined, parseParams(exp.params, code, scope), undefined, tsModule.createToken(tsModule.SyntaxKind.EqualsGreaterThanToken), genericTransform(vSlotData.data, newScope));\r\n            }\r\n            function nodeTransform(nodeData, scope) {\r\n                const child = nodeData.data;\r\n                switch (child.type) {\r\n                    case 'VElement':\r\n                        return transformElement(child, code, scope);\r\n                    case 'VExpressionContainer':\r\n                        return transformExpressionContainer(child, code, scope);\r\n                    case 'VText':\r\n                        return tsModule.createLiteral(child.value);\r\n                }\r\n            }\r\n            return children.map(child => genericTransform(child, originalScope));\r\n        }\r\n        // Remove whitespace nodes\r\n        const filtered = children.filter(child => {\r\n            return child.type !== 'VText' || child.value.trim() !== '';\r\n        });\r\n        return mainTransform(preTransform(filtered));\r\n    }\r\n    function transformStatement(statement, code, scope) {\r\n        if (statement.type !== 'ExpressionStatement') {\r\n            console.error('Unexpected statement type:', statement.type);\r\n            return tsModule.createExpressionStatement(tsModule.createLiteral(''));\r\n        }\r\n        return tsModule.createExpressionStatement(transformExpression(statement.expression, code, scope));\r\n    }\r\n    function transformFilter(filter, code, scope) {\r\n        const exp = transformExpression(filter.expression, code, scope);\r\n        // Simply convert all filter arguments into array literal because\r\n        // we just want to check their types.\r\n        // Do not care about existence of filters and matching between parameter\r\n        // and argument types because filters will not appear on component type.\r\n        const filterExps = tsModule.createArrayLiteral(filter.filters.map(f => {\r\n            return tsModule.createArrayLiteral(f.arguments.map(arg => {\r\n                const exp = arg.type === 'SpreadElement' ? arg.argument : arg;\r\n                return transformExpression(exp, code, scope);\r\n            }));\r\n        }));\r\n        return tsModule.createBinary(filterExps, tsModule.SyntaxKind.BarBarToken, exp);\r\n    }\r\n    function transformExpressionContainer(container, code, scope) {\r\n        const exp = container.expression;\r\n        if (exp) {\r\n            if (exp.type === 'VOnExpression' || exp.type === 'VForExpression' || exp.type === 'VSlotScopeExpression') {\r\n                throw new Error(`'${exp.type}' should not be transformed with 'transformExpressionContainer'`);\r\n            }\r\n            if (exp.type === 'VFilterSequenceExpression') {\r\n                return transformFilter(exp, code, scope);\r\n            }\r\n        }\r\n        // Other type of expression should parsed by TypeScript compiler\r\n        const [start, end] = expressionCodeRange(container);\r\n        const expStr = code.slice(start, end);\r\n        return parseExpression(expStr, scope, start);\r\n    }\r\n    function transformExpression(exp, code, scope) {\r\n        const [start, end] = exp.range;\r\n        const expStr = code.slice(start, end);\r\n        return parseExpression(expStr, scope, start);\r\n    }\r\n    function parseExpression(exp, scope, start) {\r\n        // Add parenthesis to deal with object literal expression\r\n        const wrappedExp = '(' + exp + ')';\r\n        const source = tsModule.createSourceFile('/tmp/parsed.ts', wrappedExp, tsModule.ScriptTarget.Latest, true);\r\n        const statement = source.statements[0];\r\n        if (!statement || !tsModule.isExpressionStatement(statement)) {\r\n            console.error('Unexpected statement kind:', statement.kind);\r\n            return tsModule.createLiteral('');\r\n        }\r\n        const parenthesis = statement.expression;\r\n        // Compensate for the added `(` that adds 1 to each Node's offset\r\n        const offset = start - '('.length;\r\n        return walkExpression(tsModule, parenthesis.expression, createWalkCallback(scope, offset, source));\r\n    }\r\n    function expressionCodeRange(container) {\r\n        const parent = container.parent;\r\n        const offset = parent.type === 'VElement' || parent.type === 'VDocumentFragment'\r\n            ? // Text node interpolation\r\n                // {{ exp }} => 2\r\n                2\r\n            : // Attribute interpolation\r\n                // v-test:[exp] => 1\r\n                // :name=\"exp\" => 1\r\n                1;\r\n        return [container.range[0] + offset, container.range[1] - offset];\r\n    }\r\n    function createWalkCallback(scope, offset, source) {\r\n        return (node, additionalScope) => {\r\n            const thisScope = scope.concat(additionalScope.map(id => id.text));\r\n            const injected = injectThis(node, thisScope, offset, source);\r\n            setSourceMapRange(injected, node, offset, source);\r\n            resetTextRange(injected);\r\n            return injected;\r\n        };\r\n    }\r\n    function parseParams(params, code, scope) {\r\n        const start = params[0].range[0];\r\n        const end = params[params.length - 1].range[1];\r\n        const paramsStr = code.slice(start, end);\r\n        // Wrap parameters with an arrow function to extract them as ts parameter declarations.\r\n        const arrowFnStr = '(' + paramsStr + ') => {}';\r\n        // Decrement the offset since the expression now has the open parenthesis.\r\n        const exp = parseExpression(arrowFnStr, scope, start - 1);\r\n        return exp.parameters;\r\n    }\r\n    function injectThis(exp, scope, start, source) {\r\n        if (tsModule.isIdentifier(exp)) {\r\n            return scope.indexOf(exp.text) < 0 ? tsModule.createPropertyAccess(tsModule.createThis(), exp) : exp;\r\n        }\r\n        if (tsModule.isObjectLiteralExpression(exp)) {\r\n            const properties = exp.properties.map(p => {\r\n                if (!tsModule.isShorthandPropertyAssignment(p)) {\r\n                    return p;\r\n                }\r\n                // Divide short hand property to name and initializer and inject `this`\r\n                // We need to walk generated initializer expression.\r\n                const initializer = createWalkCallback(scope, start, source)(p.name, []);\r\n                return tsModule.createPropertyAssignment(p.name, initializer);\r\n            });\r\n            return tsModule.createObjectLiteral(properties);\r\n        }\r\n        return exp;\r\n    }\r\n    function setSourceMapRange(exp, range, offset, source) {\r\n        tsModule.setSourceMapRange(exp, {\r\n            pos: offset + range.getStart(source),\r\n            end: offset + range.getEnd()\r\n        });\r\n        if (tsModule.isPropertyAccessExpression(exp)) {\r\n            // May be transformed from Identifier by injecting `this`\r\n            const r = tsModule.isPropertyAccessExpression(range) ? range.name : range;\r\n            tsModule.setSourceMapRange(exp.name, {\r\n                pos: offset + r.getStart(source),\r\n                end: offset + r.getEnd()\r\n            });\r\n            return;\r\n        }\r\n        if (tsModule.isArrowFunction(exp)) {\r\n            const walkBinding = (name, range) => {\r\n                tsModule.setSourceMapRange(name, {\r\n                    pos: offset + range.getStart(source),\r\n                    end: offset + range.getEnd()\r\n                });\r\n                if (tsModule.isObjectBindingPattern(name) || tsModule.isArrayBindingPattern(name)) {\r\n                    name.elements.forEach((el, i) => {\r\n                        if (tsModule.isOmittedExpression(el)) {\r\n                            return;\r\n                        }\r\n                        const elRange = range.elements[i];\r\n                        tsModule.setSourceMapRange(el, {\r\n                            pos: offset + elRange.getStart(source),\r\n                            end: offset + elRange.getEnd()\r\n                        });\r\n                        walkBinding(el.name, elRange.name);\r\n                    });\r\n                }\r\n            };\r\n            const r = range;\r\n            exp.parameters.forEach((p, i) => {\r\n                const range = r.parameters[i];\r\n                tsModule.setSourceMapRange(p, {\r\n                    pos: offset + range.getStart(source),\r\n                    end: offset + range.getEnd()\r\n                });\r\n                walkBinding(p.name, range.name);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Because Nodes can have non-virtual positions\r\n     * Set them to synthetic positions so printers could print correctly\r\n     */\r\n    function resetTextRange(exp) {\r\n        if (tsModule.isObjectLiteralExpression(exp)) {\r\n            exp.properties.forEach((p, i) => {\r\n                if (tsModule.isPropertyAssignment(p) && !tsModule.isComputedPropertyName(p.name)) {\r\n                    tsModule.setTextRange(p.name, {\r\n                        pos: -1,\r\n                        end: -1\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        if (tsModule.isTemplateExpression(exp)) {\r\n            tsModule.setTextRange(exp.head, { pos: -1, end: -1 });\r\n            exp.templateSpans.forEach(span => {\r\n                tsModule.setTextRange(span.literal, {\r\n                    pos: -1,\r\n                    end: -1\r\n                });\r\n            });\r\n        }\r\n        tsModule.setTextRange(exp, { pos: -1, end: -1 });\r\n    }\r\n    function isVAttribute(node) {\r\n        return !node.directive;\r\n    }\r\n    function isVDirective(node) {\r\n        return node.directive;\r\n    }\r\n    function isVModel(node) {\r\n        return node.directive && node.key.name.name === 'model';\r\n    }\r\n    function isVBind(node) {\r\n        return node.directive && node.key.name.name === 'bind';\r\n    }\r\n    function isVBindShorthand(node) {\r\n        return node.directive && node.key.name.name === 'bind' && node.key.name.rawName === ':';\r\n    }\r\n    function isVBindWithDynamicAttributeName(node) {\r\n        var _a;\r\n        return node.directive && ((_a = node.key.argument) === null || _a === void 0 ? void 0 : _a.type) === 'VExpressionContainer';\r\n    }\r\n    function isVOn(node) {\r\n        return node.directive && node.key.name.name === 'on';\r\n    }\r\n    function isVIf(node) {\r\n        return node.directive && node.key.name.name === 'if';\r\n    }\r\n    function isVElseIf(node) {\r\n        return node.directive && node.key.name.name === 'else-if';\r\n    }\r\n    function isVElse(node) {\r\n        return node.directive && node.key.name.name === 'else';\r\n    }\r\n    function isVFor(node) {\r\n        return node.directive && node.key.name.name === 'for';\r\n    }\r\n    function isVSlot(node) {\r\n        return node.directive && (node.key.name.name === 'slot' || node.key.name.name === 'slot-scope');\r\n    }\r\n}\r\n//# sourceMappingURL=transformTemplate.js.map","references":["/Users/yoyo930021/git/vetur/server/node_modules/@types/lodash/index.d.ts","/Users/yoyo930021/git/vetur/server/node_modules/typescript/lib/typescript.d.ts","/Users/yoyo930021/git/vetur/server/node_modules/vue-eslint-parser/index.d.ts","/Users/yoyo930021/git/vetur/server/src/services/dependencyService.ts","/Users/yoyo930021/git/vetur/server/src/services/typescriptService/walkExpression.ts"],"map":"{\"version\":3,\"file\":\"transformTemplate.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/services/typescriptService/transformTemplate.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/yoyo930021/git/vetur/server/node_modules/.cache/rollup-plugin-typescript2/placeholder/services/typescriptService/transformTemplate.d.ts","writeByteOrderMark":false,"text":"import type ts from 'typescript';\r\nimport { AST } from 'vue-eslint-parser';\r\nimport { RuntimeLibrary } from '../dependencyService';\r\nexport declare const renderHelperName = \"__vlsRenderHelper\";\r\nexport declare const componentHelperName = \"__vlsComponentHelper\";\r\nexport declare const iterationHelperName = \"__vlsIterationHelper\";\r\nexport declare const componentDataName = \"__vlsComponentData\";\r\n/**\r\n * Allowed global variables in templates.\r\n * Borrowed from: https://github.com/vuejs/vue/blob/dev/src/core/instance/proxy.js\r\n */\r\nexport declare const globalScope: string[];\r\n/**\r\n * @param tsModule Loaded TS dependency\r\n * @param childComponentNamesInSnakeCase If `VElement`'s name matches one of the child components'\r\n * name, generate expression with `${componentHelperName}__${name}`, which will enforce type-check\r\n * on props\r\n */\r\nexport declare function getTemplateTransformFunctions(tsModule: RuntimeLibrary['typescript'], childComponentNamesInSnakeCase?: string[]): {\r\n    transformTemplate: (program: AST.ESLintProgram, code: string) => ts.Expression[];\r\n    parseExpression: (exp: string, scope: string[], start: number) => ts.Expression;\r\n};\r\n"}}
